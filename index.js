const { addonBuilder, serveHTTP } = require('stremio-addon-sdk');const axios = require('axios');
const builder = new addonBuilder(require('./manifest.json'));
// Stable APIs (Nov 2025)const ANILIST_API = "https://graphql.anilist.co";const ZORO_FALLBACK = "https://api.zoroapi.com/v3"; // Mirror for streams, activeconst GOGO_MIRROR = "https://gogoapi.onrender.com"; // Backup for episodes
// Current season helperconst getCurrentSeason = () => {  const month = new Date().getMonth() + 1;  const year = new Date().getFullYear();  if (month >= 1 && month <= 3) return { season: "WINTER", year };  if (month >= 4 && month <= 6) return { season: "SPRING", year };  if (month >= 7 && month <= 9) return { season: "SUMMER", year };  return { season: "FALL", year };};
// Catalog Handler – Direct AniList (No Enime)builder.defineCatalogHandler(async (args) => {  const metas = [];
  if (args.id.startsWith('cr-season-')) {    const season = args.id.replace('cr-season-', '').toUpperCase();    const [s, y] = season.split('-');    const query = `query ($season: MediaSeason, $year: Int) {      Page(page: 1, perPage: 50) {        media(season: $season, seasonYear: $year, type: ANIME, sort: POPULARITY_DESC) {          id          title { romaji english }          coverImage { extraLarge }          bannerImage          seasonYear          format          genres        }      }    }`;    try {      const res = await axios.post(ANILIST_API, { query }, {        variables: { season: s, year: parseInt(y) }      });      res.data.data.Page.media.forEach(a => {        metas.push({          id: `anilist:${a.id}`,          type: "series",          name: a.title.english || a.title.romaji,          poster: a.coverImage.extraLarge,          background: a.bannerImage,          genres: a.genres,          releaseInfo: `${a.seasonYear}`        });      });    } catch (e) {      console.error('Catalog error:', e); // Graceful fallback    }  } else if (args.id === "cr-simulcast") {    const { season, year } = getCurrentSeason();    const query = `query ($season: MediaSeason, $year: Int) {      Page { media(season: $season, seasonYear: $year, isAdult: false, sort: POPULARITY_DESC, type: ANIME) {        id title { english romaji } coverImage { extraLarge } bannerImage      }}    }`;    try {      const res = await axios.post(ANILIST_API, { query }, { variables: { season, year } });      res.data.data.Page.media.slice(0, 30).forEach(a => metas.push({        id: `anilist:${a.id}`, type: "series",        name: a.title.english || a.title.romaji,        poster: a.coverImage.extraLarge      }));    } catch (e) { console.error('Simulcast error:', e); }  } else if (args.id === "cr-popular") {    const query = `query { Page(perPage: 50) { media(sort: POPULARITY_DESC, type: ANIME) {      id title { english romaji } coverImage { extraLarge }    }} }`;    try {      const res = await axios.post(ANILIST_API, { query });      res.data.data.Page.media.forEach(a => metas.push({        id: `anilist:${a.id}`, type: "series",        name: a.title.english || a.title.romaji,        poster: a.coverImage.extraLarge      }));    } catch (e) { console.error('Popular error:', e); }  } else if (args.id === "cr-updated") {    // Fallback to AniList trending (simulates recent)    const query = `query { Page(perPage: 40) { media(sort: TRENDING_DESC, type: ANIME) {      id title { english romaji } coverImage { extraLarge }    }} }`;    try {      const res = await axios.post(ANILIST_API, { query });      res.data.data.Page.media.forEach(a => metas.push({        id: `anilist:${a.id}`, type: "series",        name: a.title.english || a.title.romaji,        poster: a.coverImage.extraLarge      }));    } catch (e) { console.error('Updated error:', e); }  }
  return { metas };});
// Meta Handler (Direct AniList)builder.defineMetaHandler(async (args) => {  const anilistId = args.id.replace(/^(anilist:|mal:)/, '');  const query = `query ($id: Int) { Media(id: $id, type: ANIME) {    id    title { english romaji native }    coverImage { large }    bannerImage    description    genres    season    seasonYear    duration  }}`;  try {    const res = await axios.post(ANILIST_API, { query }, { variables: { id: parseInt(anilistId) } });    const a = res.data.data.Media;    if (!a) return { meta: null };
    return {      meta: {        id: `anilist:${a.id}`,        type: "series",        name: a.title.english || a.title.romaji || a.title.native,        poster: a.coverImage.large,        background: a.bannerImage,        description: a.description?.replace(/<br>/g, '\n').replace(/<[^>]*>/g, ''),        genres: a.genres,        releaseInfo: `\( {a.season} \){a.seasonYear}`,        runtime: a.duration ? `${a.duration} min` : undefined,        links: [{ name: "AniList", url: `https://anilist.co/anime/${a.id}` }]      }    };  } catch (e) {    console.error('Meta error:', e);    return { meta: null };  }});
// Stream Handler – Zoro Fallback (Stable Alternative)builder.defineStreamHandler(async (args) => {  const anilistId = args.id.replace(/^(anilist:|mal:)/, '');  const episode = parseInt(args.extra?.episode || 1);
  // First, get episodes via Gogo mirror  let epData;  try {    const info = await axios.get(`\( {GOGO_MIRROR}/series/ \){anilistId}`);    epData = info.data.episodes.find(e => e.number === episode);  } catch (e) { console.log("Gogo failed, trying Zoro..."); }
  if (!epData) return { streams: [] };
  // Zoro for sources  try {    const sources = await axios.get(`\( {ZORO_FALLBACK}/episodes/ \){epData.id}?provider=gogo`);    const streams = sources.data.sources      .filter(s => s.quality && s.quality !== "default")      .map(s => ({        url: s.url,        title: `${s.quality} [Direct HTTP]`,        behaviorHints: { notWebReady: false }      }));
    // Subs fallback    if (sources.data.subtitles?.length) {      streams.forEach(s => {        s.subtitles = sources.data.subtitles.map(sub => ({          lang: sub.lang || "English",          url: sub.url        }));      });    }
    return { streams };  } catch (e) {    console.log("Stream fetch failed:", e.message);    return { streams: [] };  }});
// v1 SDK Server Setup (Explicit PORT for Render)serveHTTP(builder.getInterface(), {  port: process.env.PORT || 7000,  logger: { info: console.log, error: console.error }});
module.exports = builder.getInterface();